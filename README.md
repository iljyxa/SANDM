## Содержание
1. [Архитектура процессора](#архитектура-процессора)  
   - [Память](#память)  
   - [Регистры](#регистры)  
2. [Формат команд](#формат-команд)  
   - [Байт-код](#байт-код)  
3. [Язык ассемблера](#язык-ассемблера)  
   - [Синтаксис](#синтаксис)  
   - [Примеры](#примеры)  
4. [Набор команд](#набор-команд)  
   - [Арифметические](#арифметические-команды)  
   - [Работа с памятью](#работа-с-памятью)  
   - [Ввод/вывод](#вводвывод)  
   - [Управление потоком](#управление-потоком)  

---

## Архитектура процессора

### Память
- **Размер**: 64 КБ (адреса от `0x0000` до `0xFFFF`).  
- **Организация**:  
  - Каждая инструкция занимает 5 байт (1 байт — код операции, 4 байта — аргумент).  
  - Память разделена на области для кода и данных.  

### Регистры
- **ACC (Accumulator)**:  
  - **Размер**: 4 байта.  
  - **Назначение**: Хранит результат операций. Доступен для чтения/записи через команды.  
- **AUX (Auxiliary)**:  
  - **Размер**: 4 байта.  
  - **Назначение**: Временное хранение аргументов. Недоступен напрямую для пользователя.  
- **IP (Instruction Pointer)**:  
  - **Размер**: 2 байта.  
  - **Назначение**: Счётчик команд. Изменяется командами `JUMP`, `SKIP*`, `JnS`.  

---

## Формат команд

### Байт-код
Каждая инструкция кодируется в 5 байт: [ Код операции (1 байт) | Аргумент (4 байта) ]

**Код операции**:
- Биты 7-3: Код команды (например, `ADD` → `00001`).  
- Биты 2-1: Модификатор типа (`C`/`W`/`SW`/`R`).  
- Бит 0: Модификатор аргумента (`0` — значение, `1` — адрес).  

Пример для `ADD W & 42`:  
```plaintext
Код операции: 00001011 (ADD + W + REF)  
Аргумент: 0x0000002A (42 в hex)  
```

---

## Язык ассемблера

### Синтаксис
- **Метки**:

  Имя метки может содержать цифры, буквы латинского алфавита в верхнем и нижнем регистрах, а также символ "_".

  Имя метки не должно начинаться с цифры.
  ```asm
  label_name: 
  ```
  Для меток доступен синтаксис без указания команды, который позволяет использовать ее в виде переменной.
  ```asm
  label_name: [Тип] Операнд
  ```
  Если в инструкции не указан операнд, то он по умолчанию равен 0, поэтому метка без указанного аргумента, эквивалентна переменной, инициализированной 0.
  В следующем примере метки label_name1, label_name2 эквивалентны.
  ```asm
  label_name1: 0
  label_name2:
  Add label_name1
  Sub label_name2
  ```
- **Команды**:

  Команды являются регистронезависимыми.
  ```asm
  [Метка:] КОМАНДА [Тип] [Модификатор] [Операнд]
  ```
- **Комментарии**:

  Комментарием считается строка, начинающаяся с двух слэшей и до конца строки. Такие строки будут проигнорированы ассемблером.
  ```asm
  // Это комментарий
  ```
- **Числа**: Поддерживаются десятичные (включая знаковые), с плавающей запятой, шестнадцатеричные (`0x`), бинарные (`0b`).

### Примеры
```asm
start:
    LOAD W 0x10     // Загрузить число 16 в ACC
    ADD W &data     // Прибавить значение по адресу data
    STORE W result  // Сохранить результат
    HALT

data: 42
result: 0
```

---

## Набор команд

### Модификаторы типов
Для всего набора команд доступны модификаторы типов. Список доступных модификаторов, доступных для конкретной команды, указаны в описании команд.

Модификатор типа изменяет функциональность процессора при обработке чисел. При этом преобразования типов не происходит и данный модификатор НЕ предназначен для преобразования из одного типа в другой.

Модификатор типа не влияет на размер занимаемой операндам памяти.

Доступные модификаторы: **C, W, SW, R**.

- **C (Char)** - целочисленный беззнаковый тип (1 байт).
- **W (Word)** - целочисленный беззнаковый тип (4 байта).
- **SW (Signed Word)** - целочисленный знаковый тип (4 байта).
- **R (Real, float)** - вещественный тип (4 байта).

### Модификатор аргумента
Для команд доступен модификатор аргумента: `&`.

Модификатор аргумента указывает процессору на то, что значение операнда является адресом другого адреса, который указывает на значение.

Таким образом, если не указан модификатор, то значение из памяти будет загружено/записано следующим образом:
`Memory[X]`.
Если указан модификатор `&`, то значение будет загружено из/записано в `Memory[Memory[X]]`.

Исключением являются команды ветвления

### Арифметические команды
| Команда | Типы        | Модификатор аргумента | Описание                                                             |
|---------|-------------|-----------------------|----------------------------------------------------------------------|
| `Add X` | C, W, SW, R | Да                    | Добавляет к регистру ACC значение по адресу X.<br/>ACC = ACC + Memory[X]  |
| `Sub X` | C, W, SW, R | Да                    | Вычитает из регистра ACC значение по адресу X.<br/>ACC = ACC - Memory[X] |
| `Mul X` | C, W, SW, R | Да                    | Умножает
| `Div X` | C, W, SW, R | Да                    |
| `Mod X` | C, W, SW    | Да                    |

### Работа с памятью
| Команда | Типы | Модификаторы | Пример |
|---------|------|--------------|--------|
| `LOAD`  | W    | `&` | `LOAD W 0xFF` |
| `STORE` | W    | —   | `STORE W result` |

**Описание**:
- `LOAD W 0xFF` — загружает в ACC значение из адреса `0xFF`.

### Ввод/вывод
| Команда | Типы | Пример |
|---------|------|--------|
| `INPUT`  | C, W, SW, R | `INPUT C` |
| `OUTPUT` | C, W, SW, R | `OUTPUT R` |

**Описание**:
- `INPUT C` — запрашивает ввод `char` в ACC.

### Управление потоком
| Команда | Типы | Пример |
|---------|------|--------|
| `JUMP`  | W    | `JUMP W start` |
| `SKIPLO`| C, W, SW, R | `SKIPLO SW 50` |
| `JnS`   | W    | `JnS W loop` |

**Описание**:
- `SKIPLO SW 50` — пропускает следующую команду, если ACC < 50.
- `JnS W loop` — сохраняет IP+1 в `loop` и прыгает на `loop+1`.

---
```