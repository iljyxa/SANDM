# Simple Assembler Non-stack Demo Machine
Эмулятор виртуального процессора с упрощенным набором команд

# Содержание

## [1. Архитектура процессора](#архитектура-процессора)
- [Память](#память)
- [Регистры](#регистры)
- [Байт-код](#байт-код)

## [2. Язык ассемблера](#язык-ассемблера)
- [Общий синтаксис](#общий-синтаксис)
- [Метки](#метки)
- [Команды](#команды)
- [Комментарии](#комментарии)
- [Числа](#числа)

## [3. Набор команд](#набор-команд)
- [Модификаторы типов](#модификаторы-типов)
- [Модификатор косвенной адресации](#модификатор-косвенной-адресации)
- [Команды](#набор-команд)
    - [Арифметические](#арифметические-команды)
    - [Работа с памятью](#работа-с-памятью)
    - [Ввод/вывод](#вводвывод)
    - [Команды переходов](#команды-переходов)

## [4. Примеры программ](#примеры-программ)
- [Вывод символов](#вывод-символов)
- [Вычисление (a+b)*c](#вычисление-abc)
- [Обмен значений](#обмен-значений)
- [Условие if-else](#условие-if-else)
- [Условие if-elseif-else](#условие-if-elseif-else)
- [Цикл for](#цикл-for)
- [Вложенный цикл for](#вложенный-цикл-for)
- [Цикл while](#цикл-while)
- [Вызов подпрограммы](#вызов-подпрограммы)
- [Реализация стека](#реализация-стека)
- [Реализация рекурсивного вызова](#реализация-рекурсивного-вызова)

---

# Архитектура процессора

## Память
- **Размер**: 64 КБ (адреса от `0x0000` до `0xFFFF`).  
- **Организация**:  
  - Каждая инструкция занимает 5 байт (1 байт — код операции, 4 байта — аргумент).  
  - Память разделена на области для кода и данных. К памяти кода программный доступ не предусмотрен, память данных может изменяться.

## Регистры
- **ACC (Accumulator)**:  
  - **Размер**: 4 байта.  
  - **Назначение**: Хранит результат операций. Доступен для чтения/записи через команды.  
- **AUX (Auxiliary)**:  
  - **Размер**: 4 байта.  
  - **Назначение**: Временное хранение аргументов. Недоступен напрямую для пользователя.  
- **IP (Instruction Pointer)**:  
  - **Размер**: 2 байта.  
  - **Назначение**: Указатель на следующую выполняемую команду. Инкрементируется автоматически. Может изменяться командами `JUMP`, `SKIP*`, `JnS`.  

---

## Байт-код

Каждая инструкция кодируется в 5 байт: [ Код операции (1 байт) | Аргумент (4 байта) ].
Инструкции кодируются последовательно. Количество байтов всегда кратно 5.
Биты команд

**Код операции**:
- Биты 7-4 (4 бита): Код команды (например, `ADD` → `0001`. Биты команд указаны в [описании команд](#набор-команд)).  
- Биты 3-2 (2 бита): Модификатор типа (`00` - `C`, `01` - `W`, `10` - `SW`, `11` - `R`).  
- Биты 0-1 (2 бита): Модификатор аргумента (`00` — значение, `01` — адрес, `10` — указатель, `11` — не используется).

Исключением является команда `Halt`, которая кодируется всегда как `11111111`.

**Операнд**:
- 4 байта (32 бита, порядок байтов little-endian).

Пример для `ADD W & 42`:  
```plaintext
Код операции: 00010101 (ADD + W + REF)  
Операнд: 0x0000002A (42 в hex)  

```

## Порядок выполнения инструкций

  Выполняемые процессором команды и их байт-код хранятся в таблице соответствий. При выполнении очередной инструкции производится чтение из памяти кода команды и поиск этого кода в таблице соответствий.

  1. Чтение инструкции по адресу, указанного в регистре `IP`. Считывается байт команды и 4 байта ее операнда.
  2. Поиск в таблице соответствий команды, соответствующей считанному байту. Если не найдена, то выполнение завершается с ошибкой.
  3. Если считана команда `Halt`, то процессор останавливается, иначе переход к пункту 3.
  4. Установка значения регистра `AUX` в соответствии с указанным (или отсутствующим) [модификатором адреса](#модификаторы-адреса).
  5. Выполняется команды.
  6. Инкрементируется регистр `IP`, если команда не устанавливает иное значение (команды ветвления).
  7. Если регистр `IP` указывает на участок памяти, в которой отсутствуют инструкции, считается, что программа выполнена и процессор останавливается. Иначе повторяется порядок начиная с 1.

---

# Язык ассемблера

## Общий синтаксис

Общий синтаксис всех инструкций приведен ниже. Для различных инструкций наличие тех или иных свойств может изменяться, однако последовательность важна, и она едина для всех инструкций.
Каждая строка исходного кода, содержащую значимые символы, транслируется в байт-код, состоящую из одной из допустимых [команд](#набор-команд).

- **Пустые строки** (или строки без значимых символов) игнорируются ассемблером.
- Если строка содержит **метку** или **числовое значение**, но не содержит явной команды, она неявно транслируется в инструкцию [`Nope`](#набор-команд).
- Команды **регистронезависимы**: `ADD`, `add` и `AdD` обрабатываются одинаково.

```asm
<Метка:> <Команда> <Тип> <&|&&> <Операнд>
```  
- **`<Метка:>`** — [символическое имя](#метки) адреса этой инструкции
- **`<Команда>`** — одна из доступных [команд](#набор-команд).
- **`<Тип>`** — [модификатор типа](#модификаторы-типов) определяет интерпретацию значения операнда:
    - `C` — константа.
    - `W` — беззнаковое слово.
    - `SW` — знаковое слово.
    - `R` — вещественное число.
- **`<&|&&>`** — [модификатор адреса](#модификаторы-адреса).
- **`<Операнд>`** — число или адрес памяти.

## Метки
  
  Метка — это символическое имя, связанное с определенным адресом.
  Имя метки может содержать цифры, буквы латинского алфавита в верхнем и нижнем регистрах, а также символ "_" и не должно начинаться с цифры.
  Фактически, при обработке компилятором, вместо имени метки вставляется ее адрес в памяти.

  Метка представляет собой отдельную инструкцию, поэтому при последовательном указании данных, важно задавать значения начиная с метки.
  Для присвоения метки адресу необходимо указать имя метки и закончить его символом `:`.  

  ```asm
  label_name: 
  ```
  Для меток доступен синтаксис без указания команды, который позволяет использовать ее в качестве переменной. Для этого после метки указывается значение инициализации данной переменной.

  ```asm
  label_name: [Тип] Значение
  ```
  Важно учитывать, что данное значение будет установлено при компиляции и не будет повторно устанавливаться при повторном выполнении инструкции.
  В следующем примере значение value всегда будет расти:
  ```asm
  Loop:
    value: 0
    Add 1
    Store value
    Jump Loop
  ```

  Если в инструкции не указан операнд, то он по умолчанию равен 0, поэтому метка без указанного аргумента, эквивалентна переменной, инициализированной 0.
  Для использования метки в качестве операнда команды необходимо указать имя метки.

  В следующем примере метки label_name1, label_name2 эквивалентны.
  ```asm
  label_name1: 0
  label_name2:
  Add label_name1
  Sub label_name2
  ```
  Для визуальной разницы меток и переменных рекомендуется для переменных всегда указывать начальное значение, а для меток опускать его.

## Комментарии

  Комментарием считается строка, начинающаяся с двух слэшей и до конца строки. Такие строки будут игнорироваться ассемблером.
  ```asm
  // Это комментарий
  ```
## Числа

  Поддерживаются десятичные (включая знаковые), с плавающей запятой, шестнадцатеричные (`0x`), бинарные (`0b`).

  ```asm
    Sub  -3          // Целое число
    Add R 3.14       // Число с плавающей запятой
    Jump 0b01101111  // Двоичное число
    JnS  0xFFFF      // Шестнадцатеричное число
  ```

## Символы

  Ассемблер поддерживает ASCII-символы. Символы указываются в одинарных кавычках и конвертируются в числовое представление соответствующим кодом.
  
  Поведение для не ASCII-символов является неопределенным.

  ```asm
    str: 'H'
    'e'
    'l'
    'l'
    'o'
  ```

---

# Набор команд

## Модификаторы типов

### **Общие сведения**
Модификаторы типов определяют, как процессор интерпретирует данные в регистрах или памяти **во время выполнения операции**. Они не преобразуют типы и не влияют на размер занимаемой памяти (все типы используют 4 байта).

### **Список модификаторов**
| Модификатор | Полное название   | Аналог        | Размер | Описание                          |
|-------------|-------------------|---------------|--------|-----------------------------------|
| `C`         | Char              | `uint8_t`     | 1 байт | Беззнаковый байт (старшие 3 байта игнорируются). |
| `W`         | Word              | `uint32_t`    | 4 байта | Беззнаковое целое число.          |
| `SW`        | Signed Word       | `int32_t`     | 4 байта | Знаковое целое число (дополнительный код). |
| `R`         | Real              | `float`       | 4 байта | Число с плавающей запятой (IEEE 754). |

#### **Общий принцип работы**
1. **Порядок выполнения**:
    - Значения загружаются по адресу (**всегда как `W`**) из памяти (если требуется).
    - Байты значения загружаются в регистр AUX.
    - Процессор интерпретирует содержимое регистров (`ACC`, `AUX`) согласно модификатору типа.
    - Выполняется операция.

2. **Пример для `Add R 0x3F800000`**:
   ```asm
   1. Memory[0xFF] → AUX (как 4 байта)
   2. ACC (4 байта) → интерпретация как `float`
   3. AUX (4 байта) → интерпретация как `float`
   4. Результат (ACC + AUX) → записывается в ACC (как `float`)
   ```

---

#### **Важные замечания**
1. **Нет преобразования типов**:
    - Если в `ACC` было целое число (`SW`), а операция выполняется с `R`, результат будет некорректен (битовая интерпретация отличается).

2. **Размер данных**:
    - Все типы используют 4 байта в памяти/регистрах, но для `C` учитывается только младший байт (остальные — нули).

---

## Модификаторы адреса
Для многих команд доступны модификаторы `&` и `&&`.

При использовании модификатора `&`, операнд считается адресом в памяти, в котором расположено значение.
При использовании модификатора `&&`, операнд считается указателем на адрес, в котором расположено значение.
Если модификатор не указан, то операнд интерпретируется как значение.

Подробное описание того, как данный модификатор влияет на конкретную команду, указано в [описании команд](#команды).

```asm
// Пример поведения модификатора для арифметических команд
// Add X <=> Add X
// Add & X <=> Add Memory[X]
// Add && X <=> Add Memory[Memory[X]]
// Где X - число (адрес)

Zero: 0  // Адрес 0 
Two: 2   // Адрес 1
Three: 3 // Адрес 2
Load Zero // ACC = 0
Add Two // ACC = ACC + Two = 0 + 1 = 1
        // Метка Two указывает на адрес 1. Так как модификатор не указан, операнд считается значением.
        // Команда Add прибавляет к ACC значение 1.
Add & Two // ACC = ACC + Memory[Two] = 1 + Memory[1] = 1 + 2 = 3
          // Для команды указан модификатор аргумента, поэтому считается, что Two является адресом значения.
Add && Two // ACC = ACC + Memory[Memory[Two]] = 3 + Memory[Memory[1]] = 3 + Memory[2] = 3 + 3 = 6
          // Для команды указан двойной модификатор, поэтому считается, что Two является адресом другого адреса, который указывает на значение.
          // Значением адреса Two(1) является 2. По адресу 2 (Three) записано значение 3, которое будет использовано.
```

## **Команды**

### Арифметические команды

| Команда | Формат                          | Описание                                                                   | Эффект от `&`                                                                                                                                                                  | Байт-код* |
|---------|---------------------------------|----------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------|
| `Add`   | `Add [C\|W\|SW\|R] [&\|&&] X`   | Сложение: `ACC += X` (или `Memory[X]`, или `Memory[Memory[X]]`).           | Без &: используется значение операнда при вычислении<br/>С &: читается значение по адресу операнда<br/>С &&: читается адрес по адресу операнда, по которому читается значение. | `0001`    |
| `Sub`   | `Sub [C\|W\|SW\|R] [&\|&&] X`   | Вычитание: `ACC -= X` (или `Memory[X]`, или `Memory[Memory[X]]`).          | Аналогично `Add`.                                                                                                                                                              | `0010`    |
| `Mul`   | `Mul [C\|W\|SW\|R] [&\|&&] X`   | Умножение: `ACC *= X` (или `Memory[X]`, или `Memory[Memory[X]]`).          | Аналогично `Add`.                                                                                                                                                              | `0011`    |
| `Div`   | `Div [C\|W\|SW\|R] [&\|&&] X`   | Деление: `ACC /= X` (или `Memory[X]`, или `Memory[Memory[X]]`).            | Аналогично `Add`.                                                                                                                                                              | `0100`    | 
| `Mod`   | `Mod [C\|W\|SW] [&\|&&] X`      | Остаток от деления: `ACC %= X` (или `Memory[X]`, или `Memory[Memory[X]]`). | Аналогично `Add`.                                                                                                                                                              | `0101`    |

### Работа с памятью
| Команда | Формат                         | Описание                                                                                          | Эффект от `&`                                                                                                                                                                                             | Байт-код* |
|---------|--------------------------------|---------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------|
| `Load`  | `Load [C\|W\|SW\|R] [&\|&&] X` | Загружает значение из памяти в регистр ACC. `ACC = X` (или `Memory[X]`, или `Memory[Memory[X]]`). | Без &: загружает в регистр значение X<br/>С &: читается значение по адресу X и загружается в регистр<br/>С &&: читается адрес по адресу X, по которому читается Memory[X], которое загружается в регистр. | `0110`    |
| `Store` | `Store [W] [&] X`              | Сохраняет значение из регистра ACC в память. `Memory[X] = ACC` (или `Memory[Memory[X]]`).         | Без &: записывает значение по адресу X<br/>С &: записывает значение по адресу Memory[X]                                                                                                                   | `0111`    |

### Ввод/вывод
| Команда  | Формат                 | Описание                                                                                                                                      | Байт-код |
|----------|------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------|----------|
| `Input`  | `Input [C\|W\|SW\|R]`  | Ввод значения в регистр ACC с интерпретацией согласно указанному типу. Останавливает выполнение процессором команд до окончания ввода.        | `1000`   |
| `Output` | `Output [C\|W\|SW\|R]` | Вывод значения из регистра ACC с интерпретацией согласно указанному типу. Тип `C` интерпретируется как ASCII-символ, все остальные как числа. | `1001`   |

### Команды переходов
| Команда   | Формат                           | Описание                                                                                                                                                                         | Эффект от `&`                                                                                                                                                                                                 | Байт-код* |
|-----------|----------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------|
| `Jump`    | `Jump [&\|&&] X`                 | Безусловный переход по адресу `X` (или `Memory[X]`, или `Memory[Memory[X]]`).                                                                                                    | Без &: `X` является адресом перехода<br/>С &: Значение по адресу `X` является адресом перехода<br/>С &&: Значение по адресу `X` является адресом, в котором записан адрес перехода.                           | `1010`    |
| `JnS`     | `JnS [&\|&&] X`                  | 1. Сохраняет адрес следующей инструкции в `X` (или `Memory[X]`, или `Memory[Memory[X]]`)<br/>2. Выполняет переход на `X + 1` (или `Memory[X] + 1`, или `Memory[Memory[X]] + 1`). | Аналогично `Jump`.                                                                                                                                                                                            | `1011`    |
| `SkipLo`  | `SkipLo [C\|W\|SW\|R] [&\|&&] X` | Пропуск следующей инструкции, если `X` (или `Memory[X]`, или `Memory[Memory[X]]`) < ACC.                                                                                         | Без &: `X` является значением сравнения<br/>С &: `X` является адресом, по которому записано значение сравнения<br/>С &&: Значение по адресу `X` является адресом, в котором записан адрес значения сравнения. | `1100`    |
| `SkipGt`  | `SkipGt [C\|W\|SW\|R] [&\|&&] X` | Пропуск следующей инструкции, если `X` (или `Memory[X]`, или `Memory[Memory[X]]`) > ACC.                                                                                         | Аналогично `SkipLo`.                                                                                                                                                                                          | `1101`    |
| `SkipEq`  | `SkipEq [C\|W\|SW\|R] [&\|&&] X` | Пропуск следующей инструкции, если `X` (или `Memory[X]`, или `Memory[Memory[X]]`) == ACC.                                                                                        | Аналогично `SkipLo`.                                                                                                                                                                                          | `1111`    |

### Прочее

| Команда | Формат                 | Описание               | Байт-код*    |
|---------|------------------------|------------------------|--------------|
| `Nope`  | `Nope [C\|W\|SW\|R] X` | Ничего не делает.      | `0000`       |
| `Halt`  | `Halt`                 | Остановка процессора.  | `11111111`** |

* - указаны первые 4 бита.
** - исключение из общего правила формирования байт-кода. Указаны все биты.
- 
---

# Примеры программ

В данной главе представлены примеры решения некоторых задач при разработке.

### Вывод символов
  Вывод одного символа с помощью символьной константы.
  ```asm
    Load 'F'
    Output C
  ```
  Вывод одного символа с помощью ASCII-кода.
  ```asm
    Load 0x46
    Output C
  ```
  Вывод символа переноса строки.
  ```asm
    Load 0x0A
    Output C
  ```

### Вычисление (a+b)*c
  ```asm
    a: 2
    b: 5
    c: 7
    Load & a // ACC = 2
    Add & b  // ACC = ACC + 5
    Mul & c  // ACC = ACC * 7
  ```

### Обмен значений
  ```asm
    a: 10
    b: 30
    
    // tmp = a
    Load & a
    tmp: 0
    Store tmp
    // a = b
    Load & b
    Store a
    // b = tmp
    Load & tmp
    Store b
  ```
  или
  ```asm
    a: 10
    b: 30
    // b = b - a
    Load & b
    Sub & a
    Store b
    // a = a + b
    Load & a
    Add & b
    Store a
    // b = a - b
    Load & a
    Sub & b
    Store b 
  ```

### Условие if-else

  ```asm
    // Пример программы для определения чётности числа
    a: 10

    Load & a
    Mod 2 // Вычисление остатка от деления

    SkipEq 0  // (Если ACC == 0) Если остаток равен 0, то пропуск следующей инструкции
    Jump Odd  // (Иначе) Если остаток не равен 0, то выполняется прыжок на метку Odd
    Even:     // (Тогда) Если остаток равен 0, то выполняются действия Even
	    // <Действия, если четное>
	    Jump End_if // Необходимо пропустить выполнение инструкций для Odd
    Odd:
	    // <Действия, если нечетное>	
    End_if:
  ```

### Условие if-elseif-else
  Первый вариант конструкции, когда требуется проверка на равенство в условиях
  ```asm
    // Программа проверяет остаток от деления числа на 3 и выполняет различные действия в зависимости от результата
    a: 10
    
    // Вычисление остатка от деления на 3
    Load & a
    Mod 3

    // Проверка остатка = 0
    Check_0:
    SkipEq 0      // (Если ACC == 0) Если остаток равен 0, то пропуск следующей инструкции
    Jump Check_1  // (Иначе ...) Если остаток не равен 0, то переход на метку Check_1
    Jump Modulo_0 // (Тогда) Если остаток равен 0, то переход на метку Modulo_0
    // Проверка остатка = 1
    Check_1:
    SkipEq 1      // (Иначе Если ACC == 1) Если остаток равен 1, то пропуск следующей строки
    Jump Modulo_2 // (Иначе) Если остаток не равен 1, то переход на метку Modulo_2
    Jump Modulo_1 // (Тогда) Если остаток равен 1, то переход на метку Modulo_1
    
    Modulo_0:
	    // <Действия при остатке = 0>
	    Jump End_if
    Modulo_1:
        // <Действия при остатке = 1>
	    Jump End_if
    Modulo_2:
        // <Действия при остатке = 2>

    End_if:
  ```
  Второй вариант конструкции, когда возможно сравнение на больше-меньше
  ```asm
    // Программа проверяет остаток от деления числа на 3 и выполняет различные действия в зависимости от результата
    a: 10
    
    // Вычисление остатка от деления на 3
    Load & a
    Mod 3
    
    SkipGt 0      // (Если ACC > 0) Если остаток от деления больше 0, тогда пропуск следующей инструкции
    Jump Modulo_0 // (Иначе) Переход на метку Modulo_0
    SkipGt 1      // (Тогда Если ACC > 1) Если остаток от деления больше 1, тогда пропуск следующей инструкции
    Jump Modulo_1 // (Иначе) Переход на метку Modulo_1
    Jump Modulo_2 // (Тогда) Переход на метку Modulo_2
    
    Modulo_0:
        // <Действия при остатке = 0>
        Jump End_if
    Modulo_1:
        // <Действия при остатке = 1>
        Jump End_if
    Modulo_2:
        // <Действия при остатке = 2>
    End_if:
  ```

### Цикл for
  В общем случае цикл, эквивалентный C-циклу `for (int i = 0; i < 10; i++)`, будет выглядеть следующим образом:
  ```asm
    i: 0  // Счетчик
    n: 10 // Количество итераций
    
    Load & i 
    Loop:
        SkipLo & n    // (Если i < 10)
        Jump End_loop // (Иначе) Выход из цикла переходом на метку End_loop
                      // (Тогда)
        // <Действия в теле цикла> 
        Add 1         // (i++)
        Jump Loop     // Переход к следующей итерации переходом на метку Loop
    End_loop:
  ```
  Однако в теле цикла, вероятнее всего, будут инструкции, изменяющие регистр ACC, который храние `i`. Поэтому данную конструкцию необходимо модифицировать, добавив загрузку-сохранение счетчика в памяти.
  ```asm
    i: 0  // Счетчик
    n: 10 // Количество итераций
     
    Loop:
        Load & i      // ACC = i
        SkipLo & n    // (Если i < 10)
        Jump End_loop // (Иначе) Выход из цикла переходом на метку End_loop
                      // (Тогда)
        // <Действия в теле цикла> 
        Load & i      // ACC = i
	    Add 1         // ACC = ACC + 1
	    Store i       // i = ACC
        Jump Loop     // Переход к следующей итерации переходом на метку Loop
    End_loop:
  ```

### Вложенный цикл for
  Пример C-цикла:
  ```c++
    for (int i = 0; i < 5; i++) {
        for (int j = 0; j < 10; j++) {
            // <Действия во внутреннем цикле>
        }
    }
  ```
  Данный цикл можно реализовать следующим образом:
  ```asm
    i: 0  // Счетчик
    n: 5  // Количество итераций внешнего цикла
     
    Loop:
        Load & i      // ACC = i
        SkipLo & n    // (Если i < 5)
        Jump End_loop // (Иначе) Выход из цикла переходом на метку End_loop
                      // (Тогда) Продолжается выполнение программы 
        
        // Так как переменная j при последующих итерациях не будет инициализироваться, 
        // на каждой итерации перед началом вложенного цикла ее необходимо обнулять.
        Load 0
        Store j              
        j: 0
        m: 10
        Inner_loop:
            Load & j            // ACC = j
            SkipLo & m          // (Если j < 10)
            Jump End_inner_loop // (Иначе) Выход из внутреннего цикла переходом на метку End_inner_loop
            
            // <Действия во внутреннем цикле>
            
            Load & j      // --|
	        Add 1         //    } (j++)
	        Store j       // --|
	        
            Jump Inner_loop     // Переход к следующей итерации внутреннего цикла переходом на метку Loop
        End_inner_loop:
        
        Load & i      // --|
	    Add 1         //    } (i++)
	    Store i       // --|
	    
        Jump Loop     // Переход к следующей итерации внешнего цикла переходом на метку Loop
    End_loop:
  ```

### Цикл while
  Пример C-цикла:
  ```c++
    bool n = true;
    while (n) {
        // <Действия цикла, если n == true>
    }
  ```
  ```asm
    n: 1
    Loop:
        Load & n // Регистр ACC и n могут изменяться в цикле
        SkipEq 1
        Jump End_loop
        // <Действия цикла, если n == 1>
        Jump Loop
    End_loop:
  ```

### Вызов подпрограммы
  ```asm
    // <действия программы>
    JnS program1
    // <действия программы, продолжающиеся после возврата из подпрограммы>
    Halt

    program1:
	    // <действия подпрограммы>
	    Jump & program1 // возврат из подпрограммы
  ```

### Реализация стека
  ```asm
    // Указатель на адрес помещения значения
    // Указывается свободное адресное пространство начиная с данного
    StackPointer: 0xFF00
    
    Load 5
    JnS Push // Положить на стек 5 (ACC), StackPointer = 0xFF01
    JnS Pop  // Взять со стека 5 и положить в ACC , StackPointer = 0xFF00
    Halt
    
    // Процедура помещает на стек значение ACC.
    // Увеличивает значение StackPointer на 1.
    Push:
        // Помещение на стек значения ACC
        Push_ACC_original: 0
        Store & StackPointer
        Store Push_ACC_original
        // Инкремент указателя StackPointer
        Load & StackPointer
        Add W 1
        Store StackPointer
        // Восстановление значения ACC
        Load & Push_ACC_original
        
        Jump & Push
    
    // Процедура достает со стека значение по указателю StackPointer и помещает в ACC.   
    // Уменьшает значение StackPointer на 1.
    Pop:
        // StackPointer указывает на адрес помещения. Последнее значение хранится по предыдущему адресу.
        Load & StackPointer
        Sub W 1
        Store StackPointer   // Запись нового значения указателя
        Load && StackPointer // Запись в ACC значения из стека
        
        Jump & Pop
  ```

### Реализация рекурсивного вызова
  Данная программа показывает пример реализации рекурсивного вызова подпрограммы с использованием [стека](#реализация-стека).
  Данный алгоритм не является оптимальным, а лишь демонстрирует принцип рекурсивного вызова.
  ```asm
    StackPointer: 0xFF00
    
    // Помещение параметра N на стек
    Load 10
    JnS Push
    // Вызов подпрограммы
    JnS Factorial
    // Вывод результата
    Output W
    // Перенос строки
    Load 0x0A
    Output C
    // Завершение программы
    Halt
    
    // Рекурсивная функция вычисления факториала N.
    // Параметр N передается через стек.
    // Результат вычисления помещается в ACC
    Factorial:
    	Factorial_tmp0: 0
    	// Получение значения параметра с сохранением его на стеке
    	JnS Pop
    	JnS Push
    	Store Factorial_tmp0
    	// Сохранение адреса возврата на стеке для возможности рекурсивного вызова
    	Load & Factorial
    	JnS Push
    	// Восстановление в ACC = N
    	Load & Factorial_tmp0
    	SkipLo W 2 // Если N <= 1 то это базовый случай и результат 1
   		Jump Factorial_N // Иначе вычисление факториала N
    	Factorial_base_case:
    		// f(N) = 1
    		Load 1
    		Jump Factorial_return
    	Factorial_N:
    		// f(N) = N * f(n - 1)
    		// Рекурсивный вызов подпрограммы с параметром N - 1
    		Sub W 1
    		JnS Push
    		JnS Factorial
    		
    		Factorial_tmp2: 0 // Для сохранения результата вычисления подпрограммы
    		Store Factorial_tmp2
    		JnS Pop				  // ACC = N - 1
    		Add W 1				  // ACC = ACC + 1
    		Mul W & Factorial_tmp2 // ACC = ACC * f(n - 1)
    	
    	// Возврат из подпрограммы			
    	Factorial_return:
    	// Необходимо восстановить адрес возврата. Так как в ACC сейчас вычисленное значение,
    	// его необходимо сохранить в переменной.
    	Factorial_tmp3: 0
    	Store Factorial_tmp3
    	// Восстановление адреса возврата
    	JnS Pop
    	Store Factorial
    	// Восстановление вычисленного значения
    	Load & Factorial_tmp3
    	// Возврат из подпрограммы
    	Jump & Factorial
  ```