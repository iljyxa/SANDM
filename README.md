# Simple Assembler Non-stack Demo Machine

# Содержание

## [Архитектура процессора](#архитектура-процессора)
- [Память](#память)
- [Регистры](#регистры)
- [Байт-код](#байт-код)

## [Язык ассемблера](#язык-ассемблера)
- [Общий синтаксис](#общий-синтаксис)
- [Метки](#метки)
- [Команды](#команды)
- [Комментарии](#комментарии)
- [Числа](#числа)

## [Набор команд](#набор-команд)
- [Модификаторы типов](#модификаторы-типов)
- [Модификатор косвенной адресации](#модификатор-косвенной-адресации)
- [Команды](#команды-процессора)
    - [Арифметические](#арифметические-команды)
    - [Работа с памятью](#работа-с-памятью)
    - [Ввод/вывод](#вводвывод)
    - [Команды переходов](#команды-переходов)

---

# Архитектура процессора

## Память
- **Размер**: 64 КБ (адреса от `0x0000` до `0xFFFF`).  
- **Организация**:  
  - Каждая инструкция занимает 5 байт (1 байт — код операции, 4 байта — аргумент).  
  - Память разделена на области для кода и данных.  

## Регистры
- **ACC (Accumulator)**:  
  - **Размер**: 4 байта.  
  - **Назначение**: Хранит результат операций. Доступен для чтения/записи через команды.  
- **AUX (Auxiliary)**:  
  - **Размер**: 4 байта.  
  - **Назначение**: Временное хранение аргументов. Недоступен напрямую для пользователя.  
- **IP (Instruction Pointer)**:  
  - **Размер**: 2 байта.  
  - **Назначение**: Счётчик команд. Изменяется командами `JUMP`, `SKIP*`, `JnS`.  

---

## Байт-код

Каждая инструкция кодируется в 5 байт: [ Код операции (1 байт) | Аргумент (4 байта) ].
Записываются последовательно. Каждая строка содержит 1 инструкцию.

**Код операции**:
- Биты 7-3: Код команды (например, `ADD` → `00001`).  
- Биты 2-1: Модификатор типа (`C`/`W`/`SW`/`R`).  
- Бит 0: Модификатор аргумента (`0` — значение, `1` — адрес).

**Операнд**:
- 4 байта (32 бита, порядок байтов little-endian).

Пример для `ADD W & 42`:  
```plaintext
Код операции: 00001011 (ADD + W + REF)  
Операнд: 0x0000002A (42 в hex)  

```

---

# Язык ассемблера

## Общий синтаксис
```
<Команда> [Тип] [&|&&] <Операнд>
```  
- **`[Тип]`** — модификатор типа определяет интерпретацию значения операнда:
    - `C` — константа.
    - `W` — беззнаковое слово.
    - `SW` — знаковое слово.
    - `R` — вещественное число.
- **`[&|&&]`** — модификатор адреса.
- **`<Операнд>`** — число или адрес памяти.

## Метки
  
  Метка - это символическое имя, связанное с определенным адресом.
  Имя метки может содержать цифры, буквы латинского алфавита в верхнем и нижнем регистрах, а также символ "_".
  Фактически, при обработке компилятором, вместо имени метки вставляется ее адрес в памяти.

  Имя метки не должно начинаться с цифры.
  ```asm
  label_name: 
  ```
  Для меток доступен синтаксис без указания команды, который позволяет использовать ее в виде переменной.
  ```asm
  label_name: [Тип] Операнд
  ```
  Если в инструкции не указан операнд, то он по умолчанию равен 0, поэтому метка без указанного аргумента, эквивалентна переменной, инициализированной 0.
  В следующем примере метки label_name1, label_name2 эквивалентны.
  ```asm
  label_name1: 0
  label_name2:
  Add label_name1
  Sub label_name2
  ```
## Команды

  Команды являются регистронезависимыми.
  ```asm
  [Метка:] КОМАНДА [Тип] [Модификатор] [Операнд]
  ```
## Комментарии

  Комментарием считается строка, начинающаяся с двух слэшей и до конца строки. Такие строки будут проигнорированы ассемблером.
  ```asm
  // Это комментарий
  ```
## Числа
Поддерживаются десятичные (включая знаковые), с плавающей запятой, шестнадцатеричные (`0x`), бинарные (`0b`).

    ```asm
    Sub  -3          // Целое число
    Add R 3.14       // Число с плавающей запятой
    Jump 0b01101111  // Двоичное число
    JnS  0xFFFF      // Шестнадцатеричное число
    ```
---

# Набор команд

## Модификаторы типов

### **Общие сведения**
Модификаторы типов определяют, как процессор интерпретирует данные в регистрах или памяти **во время выполнения операции**. Они не преобразуют типы и не влияют на размер занимаемой памяти (все типы используют 4 байта).

### **Список модификаторов**
| Модификатор | Полное название   | Аналог        | Размер | Описание                          |
|-------------|-------------------|---------------|--------|-----------------------------------|
| `C`         | Char              | `uint8_t`     | 1 байт | Беззнаковый байт (старшие 3 байта игнорируются). |
| `W`         | Word              | `uint32_t`    | 4 байта | Беззнаковое целое число.          |
| `SW`        | Signed Word       | `int32_t`     | 4 байта | Знаковое целое число (дополнительный код). |
| `R`         | Real              | `float`       | 4 байта | Число с плавающей запятой (IEEE 754). |

#### **Общий принцип работы**
1. **Порядок выполнения**:
    - Значения загружаются по адресу (**всегда как `W`**) из памяти (если требуется).
    - Байты значения загружаются в регистр AUX.
    - Процессор интерпретирует содержимое регистров (`ACC`, `AUX`) согласно модификатору типа.
    - Выполняется операция.

2. **Пример для `Add R 0x3F800000`**:
   ```asm
   1. Memory[0xFF] → AUX (как 4 байта)
   2. ACC (4 байта) → интерпретация как `float`
   3. AUX (4 байта) → интерпретация как `float`
   4. Результат (ACC + AUX) → записывается в ACC (как `float`)
   ```

---

#### **Важные замечания**
1. **Нет преобразования типов**:
    - Если в `ACC` было целое число (`SW`), а операция выполняется с `R`, результат будет некорректен (битовая интерпретация отличается).

2. **Размер данных**:
    - Все типы используют 4 байта в памяти/регистрах, но:
        - Для `C` учитывается только младший байт (остальные — нули).

---

## Модификаторы адреса
Для многих команд доступны модификаторы `&` и `&&`.

При использовании модификатора `&`, операнд считается адресом в памяти, в котором расположено значение.
При использовании модификатора `&&`, операнд считается адресом в памяти, который ссылается на другой адрес, в котором расположено значение.
Если модификатор не указан, то операнд интерпретируется как значение.

Подробное описание того, как данный модификатор влияет на конкретную команду, указано в описании команд.

```asm
// Пример поведения модификатора для арифметических команд
// Add X <=> Add X
// Add & X <=> Add Memory[X]
// Add && X <=> Add Memory[Memory[X]]
// Где X - число (адрес)

Zero: 0  // Адрес 0 
Two: 2   // Адрес 1
Three: 3 // Адрес 2
Load Zero // ACC = 0
Add Two // ACC = ACC + Two = 0 + 1 = 1
        // Метка Two указывает на адрес 1. Так как модификатор не указан, операнд считается значением.
        // Команда Add прибавляет к ACC значение 1.
Add & Two // ACC = ACC + Memory[Two] = 1 + Memory[1] = 1 + 2 = 3
          // Для команды указан модификатор аргумента, поэтому считается, что Two является адресом значения.
Add && Two // ACC = ACC + Memory[Memory[Two]] = 3 + Memory[Memory[1]] = 3 + Memory[2] = 3 + 3 = 6
          // Для команды указан двойной модификатор, поэтому считается, что Two является адресом другого адреса, который указывает на значение.
          // Значением адреса Two(1) является 2. По адресу 2 (Three) записано значение 3, которое будет использовано.
```

## **Команды**

### Арифметические команды

| Команда | Формат                        | Описание                                                                  | Эффект от `&`                                                                                                                                                                  |
|---------|-------------------------------|---------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `Add`   | `Add [C\|W\|SW\|R] [&\|&&] X` | Сложение: `ACC += X` (или `Memory[X]`, или `Memory[Memory[X]]`).           | Без &: используется значение операнда при вычислении<br/>С &: читается значение по адресу операнда<br/>С &&: читается адрес по адресу операнда, по которому читается значение. |
| `Sub`   | `Sub [C\|W\|SW\|R] [&\|&&] X`     | Вычитание: `ACC -= X` (или `Memory[X]`, или `Memory[Memory[X]]`).         | Аналогично `Add`.                                                                                                                                                              |
| `Mul`   | `Mul [C\|W\|SW\|R] [&\|&&] X`     | Умножение: `ACC *= X` (или `Memory[X]`, или `Memory[Memory[X]]`).         | Аналогично `Add`.                                                                                                                                                              |
| `Div`   | `Div [C\|W\|SW\|R] [&\|&&] X`     | Деление: `ACC /= X` (или `Memory[X]`, или `Memory[Memory[X]]`).           | Аналогично `Add`.                                                                                                                                                              |
| `Mod`   | `Mod [C\|W\|SW] [&\|&&] X`        | Остаток от деления: `ACC %= X` (или `Memory[X]`, или `Memory[Memory[X]]`). | Аналогично `Add`.                                                                                                                                                              |

### Работа с памятью
| Команда | Формат            | Описание                                                                                 | Эффект от `&`                                                                                                                                                                                             |
|---------|-------------------|------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `Load`  | `Load [W] [&\|&&] X` | Загружает значение из памяти в регистр ACC. `ACC = X` (или `Memory[X]`, или `Memory[Memory[X]]`). | Без &: загружает в регистр значение X<br/>С &: читается значение по адресу X и загружается в регистр<br/>С &&: читается адрес по адресу X, по которому читается Memory[X], которое загружается в регистр. |
| `Store` | `Store [W] [&] X` | Сохраняет значение из регистра ACC в память. `Memory[X] = ACC` (или `Memory[Memory[X]]`)    | Без &: записывает значение по адресу X<br/>С &: записывает значение по адресу Memory[X]                                                                                                                   |

### Ввод/вывод
| Команда  | Формат    | Описание                                                                  |
|----------|-----------|---------------------------------------------------------------------------|
| `Input`  | `Input [C\|W\|SW\|R]`  | Ввод значения в регистр ACC с интерпретацией согласно указанному типу.    |
| `Output` | `Output [C\|W\|SW\|R]` | Вывод значения из регистра ACC с интерпретацией согласно указанному типу. |

### Команды переходов
| Команда   | Формат                           | Описание                                                                                                                                                                         | Эффект от `&`                                                                                                                                                                                                 |
|-----------|----------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `Jump`    | `Jump [&\|&&] X`                 | Безусловный переход по адресу `X` (или `Memory[X]`, или `Memory[Memory[X]]`).                                                                                                    | Без &: `X` является адресом перехода<br/>С &: Значение по адресу `X` является адресом перехода<br/>С &&: Значение по адресу `X` является адресом, в котором записан адрес перехода.                           |
| `JnS`     | `JnS [&\|&&] X`                  | 1. Сохраняет адрес следующей инструкции в `X` (или `Memory[X]`, или `Memory[Memory[X]]`)<br/>2. Выполняет переход на `X + 1` (или `Memory[X] + 1`, или `Memory[Memory[X]] + 1`). | Аналогично `Jump`.                                                                                                                                                                                            |
| `SkipLo`  | `SkipLo [C\|W\|SW\|R] [&\|&&] X` | Пропуск следующей инструкции, если `X` (или `Memory[X]`, или `Memory[Memory[X]]`) < ACC.                                                                                         | Без &: `X` является значением сравнения<br/>С &: `X` является адресом, по которому записано значение сравнения<br/>С &&: Значение по адресу `X` является адресом, в котором записан адрес значения сравнения. |
| `SkipGt`  | `SkipGt [C\|W\|SW\|R] [&\|&&] X` | Пропуск следующей инструкции, если `X` (или `Memory[X]`, или `Memory[Memory[X]]`) > ACC.                                                                                         | Аналогично `SkipLo`.                                                                                                                                                                                          |
| `SkipEq`  | `SkipEq [C\|W\|SW\|R] [&\|&&] X` | Пропуск следующей инструкции, если `X` (или `Memory[X]`, или `Memory[Memory[X]]`) == ACC.                                                                                        | Аналогично `SkipLo`.                                                                                                                                                                                          |