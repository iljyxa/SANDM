#ifndef MAIN_WINDOW_HPP
#define MAIN_WINDOW_HPP

#include <QMainWindow>
// ReSharper disable once CppUnusedIncludeDirective
#include <QLabel>

#include "core/assembler.hpp"
#include "core/common_definitions.hpp"
#include "core/virtual_machine.hpp"
#include "gui/code_editor.hpp"
#include "gui/console.hpp"
#include "gui/memory_model.hpp"
#include "gui/memory_view.hpp"
#include "gui/register_editor.hpp"
#include "gui/virtual_machine_controller.hpp"

/**
 * @brief Главное окно приложения SANDM (Simple Assembler Non-stack Demo Machine)
 *
 * Класс реализует основное окно приложения, содержащее редактор кода,
 * отображение регистров, памяти и консоль ввода-вывода.
 */
class MainWindow final : public QMainWindow, public ProcessorIo {
    Q_OBJECT

public:
    /**
     * @brief Конструктор главного окна
     * @param parent Родительский виджет (по умолчанию nullptr)
     */
    explicit MainWindow(QWidget* parent = nullptr);

signals:
    /**
     * @brief Сигнал, испускаемый при применении новой темы
     */
    void ThemeApplied();
    /**
     * @brief Сигнал готовности данных для вывода
     *
     * Внутренний сигнал для асинхронного вывода
     *
     * @param bytes Данные, готовые для вывода, в формате байтов
     * @param type Тип данных, указывающий способ их интерпретации
     */
    void OutputReady(snm::Bytes bytes, snm::Type type);

private slots:
    // === Управление виртуальной машиной ===
    /**
     * @brief Обработчик запуска виртуальной машины. Перед запуском сбрасывает текущее состояние виртуальной машины
     * и выполняет трансляцию исходного кода (при необходимости) и его загрузку.
     */
    void OnRun();
    /**
     * @brief Обработчик выполнения одного шага программы. Если виртуальная машина остановлена, выполняет трансляцию
     * исходного кода (при необходимости) и его загрузку.
     */
    void OnStep();
    /**
     * @brief Обработчик запуска виртуальной машины в режиме отладки. Перед запуском сбрасывает текущее состояние
     * виртуальной машины и выполняет трансляцию исходного кода (при необходимости) и его загрузку.
     * В режиме отладки выполнение приостанавливается на точках останова.
     */
    void OnDebug();
    /**
     * @brief Обработчик, выоплняемый при запросе обновления состояния виртуальной машины.
     */
    void OnUpdateVm() const;
    /**
     * @brief Обработчик, выполняемой при сбросе виртуальной машины
     */
    void OnResetVm();
    /**
     * @brief Обработчик изменения состояния виртуальной машины
     * @param state Новое состояние виртуальной машины
     * @param debugging Флаг режима отладки
     */
    void OnStateVmChanged(VmState state, bool debugging) const;
    /**
     * @brief Обработчик возникновения ошибки. Выполняет вывод ошибки в консоль.
     * @param error Сообщение об ошибке
     */
    void OnErrorOccurred(const QString& error) const;
    /**
     * @brief Обработчик изменения кода в редакторе. Устанавливает признак необходимости обновления байт-кода
     */
    void OnCodeChanged();

    // === Файловые операции ===
    /**
     * @brief Обработчик открытия файла
     */
    void OnOpenFile();
    /**
     * @brief Обработчик сохранения файла
     */
    void OnSaveFile();
    /**
     * @brief Обработчик сохранения файла с выбором имени
     */
    void OnSaveAsFile();

    // === Взаимодействие с пользователем ===
    /**
     * @brief Обновление строки состояния
     * @param value Значение в ячейке памяти
     * @param address
     */
    void UpdateStatusBar(std::optional<snm::Word> value = std::nullopt, int address = -1) const;

    // === Справка и информация ===
    void ShowHelp();
    void ShowAbout();

private:
    // === Компоненты интерфейса ===
    VirtualMachineController* vm_controller_;
    std::unique_ptr<Assembler> assembler_;
    CodeEditor* code_editor_;
    RegisterEditor* register_editor_;
    MemoryModel* memory_table_model_;
    MemoryView* memory_table_view_;
    Console* console_;
    QToolBar* tool_bar_;
    QStatusBar* status_bar_;
    QMenu* examples_menu_;

    // === Действия панели инструментов ===
    QAction* action_start_;
    QAction* action_stop_;
    QAction* action_pause_continue_;
    QAction* action_debug_;
    QAction* action_step_;

    // === Состояние приложения ===
    QString current_file_path_; ///< Путь к текущему открытому файлу
    bool is_bytecode_fresh_; ///< Флаг актуальности байт-кода

    /**
     * @brief Создает панель инструментов основного окна приложения.
     *
     * Метод инициализирует панель инструментов, добавляет на нее действия для управления
     * выполнением программы, включая запуск, отладку, паузу/продолжение, остановку и шаг.
     * Каждое из действий получает соответствующую иконку, горячие клавиши, а также
     * соединяется со слотами или функциями обратного вызова для выполнения связанных операций.
     */
    void CreateToolBar();
    /**
     * @brief Устанавливает видимость иконок панели инструментов в зависимости от состояния виртуальной машины.
     *
     * Метод изменяет отображение действий на панели инструментов в зависимости от текущего состояния виртуальной машины
     * и режима отладки. Например, действия "Пуск" и "Отладка" видимы только, если машина остановлена, а "Пауза/Продолжить"
     * переключается в зависимости от состояний "Пауза" и "Выполнение".
     *
     * @param state Текущее состояние виртуальной машины (STOPPED, RUNNING, PAUSED)
     * @param debugging Флаг, указывающий, выполняется ли виртуальная машина в режиме отладки (по умолчанию false)
     */
    void SetToolbarActions(VmState state, bool debugging) const;
    /**
     * @brief Обновляет байт-код для виртуальной машины
     *
     * Метод компилирует текст программы из редактора, загружает скомпилированный
     * байт-код и карту соответствия в виртуальную машину. В случае ошибки компиляции
     * выводит сообщение в консоль.
     *
     * @return true, если байт-код успешно обновлен, иначе false
     */
    bool UpdateByteCode();
    /**
     * @brief Создает структуру главного меню приложения
     *
     * Метод отвечает за инициализацию и настройку главного меню пользовательского интерфейса,
     * включая разделы "Файл", "Эмулятор", "Примеры" и "Помощь". Также устанавливает соответствующие
     * действия и их горячие клавиши, а также привязывает сигналы и слоты для обработки событий
     * выбора пунктов меню.
     */
    void CreateMenus();
    /**
     * @brief Загрузка и отображение доступных примеров в меню.
     *
     * Метод выполняет сканирование ресурсов приложения для поиска
     * примеров, добавляет их в меню примеров и связывает соответствующие
     * действия с загрузкой найденных примеров. Если примеры отсутствуют,
     * добавляется заглушка с сообщением "Нет доступных примеров".
     */
    void LoadExamples();
    /**
     * @brief Загружает пример кода из указанного ресурса
     *
     * Этот метод заменяет текущий текст редактора содержимым файла,
     * хранящегося в ресурсе по заданному пути. Если в редакторе есть несохраненные изменения,
     * пользователю будет предложено подтверждение перед заменой.
     *
     * @param resource_path Путь к ресурсу, содержащему пример кода, который нужно загрузить.
     * Должен быть строкой с допустимым форматом пути для QFile.
     */
    void LoadExampleFromResource(const QString& resource_path);
    /**
     * @brief Создает меню настроек приложения
     *
     * Метод добавляет в главное меню приложения пункт "Настройки" с подменю выбора темы интерфейса.
     * Подменю позволяет выбрать одну из трех доступных тем: "Системная", "Светлая" и "Темная".
     * Выбор темы влияет на интерфейс приложения, изменения вступают в силу сразу после выбора.
     * Реализовано использование QActionGroup для упрощения управления состоянием выбора.
     */
    void CreateSettingsMenu();
    /**
     * @brief Применяет пользовательскую тему интерфейса
     *
     * Метод настраивает цветовую палитру основного окна приложения в соответствии
     * с выбранной пользовательской темой, изменяя цвета окон, текста, кнопок и других элементов.
     * После применения изменений отправляется сигнал ThemeApplied().
     */
    void ApplyTheme();
    /**
     * @brief Настройка пользовательского интерфейса главного окна
     *
     * Метод инициализирует элементы пользовательского интерфейса, устанавливает
     * модели данных для представлений и организует их размещение с помощью сплиттеров.
     * Код выполняет следующие действия:
     * - Устанавливает модель данных для представления таблицы памяти.
     * - Настраивает ширину колонок таблицы памяти.
     * - Создаёт вертикальный и горизонтальный сплиттеры для компоновки виджетов.
     * - Размещает редактор регистров, таблицу памяти и консоль в вертикальном сплиттере.
     * - Сочетает редактор кода с вертикальным сплиттером в горизонтальном сплиттере.
     * - Устанавливает данный горизонтальный сплиттер в качестве центрального виджета.
     * - Настраивает строку состояния для главного окна.
     */
    void SetupUi();
    /**
     * @brief Настраивает подключения сигналов и слотов для компонентов главного окна
     *
     * Метод отвечает за связывание сигналов и слотов различных компонентов пользовательского интерфейса приложения с соответствующей логикой обработки.
     * Это включает в себя реакцию на изменения состояния виртуальной машины, обновление представлений памяти и регистров, обработку событий от редактора кода,
     * а также управление статусной строкой приложения.
     */
    void SetupConnections();

    /**
     * @brief Запрашивает ввод от пользователя через консоль
     *
     * Метод инициирует асинхронный процесс получения строки ввода от пользователя,
     * конвертирует эту строку в массив байтов в соответствии с указанным типом данных
     * и передает результат в колбэк-функцию.
     *
     * @param type Тип данных, к которому будет приведена введенная строка
     * @param callback Колбэк-функция, принимающая массив байтов, полученный из пользовательского ввода
     */
    void InputRequest(snm::Type type, InputCallback callback) override;
    /**
     * @brief Обрабатывает запрос на вывод данных
     *
     * Метод вызывает сигнал OutputReady с переданными данными и их типом.
     *
     * @param bytes Данные, которые необходимо вывести
     * @param type Тип данных для вывода
     */
    void OutputRequest(snm::Bytes bytes, snm::Type type) override;
    /**
     * @brief Вывод данных в консоль приложения
     *
     * Метод преобразует массив байт в строку в соответствии с указанным типом,
     * а затем выводит преобразованную строку в консоль.
     *
     * @param bytes Массив байт, который необходимо преобразовать и вывести
     * @param type Тип данных, по которому осуществляется преобразование массива байт
     */
    void Output(snm::Bytes bytes, snm::Type type) const;
};

#endif
