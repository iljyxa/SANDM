#ifndef PROCESSOR_HPP
#define PROCESSOR_HPP

#include <bitset>
#include <functional>
#include <thread>
#include <unordered_map>

#include "core/common_definitions.hpp"
#include "core/memory_manager.hpp"
#include "core/processor_io.hpp"
#include "core/processor_observer.hpp"

struct Registers {
    common::Bytes accumulator{};
    common::Bytes auxiliary{};
    common::DoubleByte instruction_pointer = 0;
};

class Processor {
public:
    explicit Processor(MemoryManager& memory, ProcessorObserver* observer = nullptr, ProcessorIo* io = nullptr);

    /**
     * @brief Запускает выполнение инструкций процессора.
     *
     * Цикл продолжает выполняться до изменения состояния `is_running_` на `false`, что может быть выполнено
     * посредством вызова других методов, таких как Stop() или до установки регистра IP на адрес, по которому нет инструкций.
     */
    void Run();
    /**
     * @brief Выполняет одну инструкцию процессора.
     *
     * Метод выполняет одну инструкцию, определенную текущим значением регистра указателя инструкций (IP).
     * На время выполнения инструкции статус устанавливается в активный.
     */
    void Step();
    /**
     * @brief Останавливает выполнение инструкций процессора.
     *
     * Устанавливает внутреннее состояние процессора `is_running_` в значение `false`.
     * Это состояние используется для завершения активного цикла выполнения инструкций.
     */
    void Stop();
    /**
     * @brief Выполняет сброс состояния процессора.
     *
     * Устанавливает аккумулятор, вспомогательный регистр и регистр указателя инструкций в начальное состояние (значение 0).
     * Сбрасывает статус выполнения процессора.
     */
    void Reset();
    /**
     * @brief Возвращает структуру, содержащую текущие значения всех регистров процессора.
     *
     * Метод предоставляет доступ к текущему состоянию регистров, включая аккумулятор, вспомогательный регистр
     * и указатель инструкций. Эти данные могут быть использованы для анализа или отладки выполнения инструкций процессора.
     *
     * @return Константная ссылка на структуру Registers, содержащую значения регистров процессора.
     */
    const Registers& GetRegisters() const;
    /**
     * @brief Устанавливает наблюдателя для процессора.
     *
     * Позволяет задать объект наблюдателя для отслеживания изменений состояния процессора.
     * Если наблюдатель не указан (равен nullptr), текущий наблюдатель будет удалён.
     *
     * @param observer Указатель на объект класса ProcessorObserver для получения уведомлений
     * о событиях процессора. По умолчанию равен nullptr.
     */
    void SetObserver(ProcessorObserver* observer);
    /**
     * @brief Устанавливает объект ввода-вывода для процессора.
     *
     * Метод позволяет задать объект класса ProcessorIo, который будет использоваться процессором
     * для выполнения операций ввода-вывода. При вызове данного метода текущий объект ввода-вывода заменяется.
     *
     * @param io Указатель на объект ProcessorIo, который будет использоваться для операций ввода-вывода.
     */
    void SetIo(ProcessorIo* io);
    /**
     * @brief Возвращает текущее значение аккумулятора процессора.
     *
     * Аккумулятор используется для хранения результатов вычислений и операций процессора.
     * Данный метод предоставляет доступ к текущему значению аккумулятора.
     *
     * @return Константная ссылка на объект типа `common::Bytes`, содержащий текущее значение аккумулятора.
     */
    const common::Bytes& GetAccumulator() const;
    /**
     * @brief Возвращает текущее значение регистра указателя инструкций (IP).
     *
     * Указатель инструкций используется для определения адреса следующей инструкции,
     * которая будет выполнена процессором.
     *
     * @return Константная ссылка на объект типа `common::DoubleByte`, содержащий текущее значение регистра указателя инструкций.
     */
    const common::DoubleByte& GetInstructionPointer() const;
    /**
     * @brief Устанавливает значение регистра указателя инструкций (IP).
     *
     * Метод обновляет регистр указателя инструкций значением, переданным в качестве аргумента.
     * При изменении значения регистра вызывается уведомление наблюдателя. Если значение превышает
     * размер доступной памяти процессора, работа процессора завершится путём изменения состояния.
     *
     * @param value Новое значение указателя инструкций, передаваемое в виде объекта типа `common::DoubleByte`.
     */
    void SetInstructionPointer(common::DoubleByte value);
    /**
     * @brief Возвращает текущее значение вспомогательного регистра.
     *
     * Метод позволяет получить доступ к вспомогательным данным, которые хранятся
     * в соответствующем регистре процессора.
     *
     * @return Константная ссылка на объект типа `common::DoubleByte`, содержащий текущее значение вспомогательного регистра.
     */
    const common::Bytes& GetAuxiliary() const;
    /**
     * @brief Проверяет, выполняется ли процессор в текущий момент.
     *
     * Возвращает текущее состояние процессора, отражающее, находится ли он в режиме выполнения инструкций.
     * Это позволяет узнать, активен ли процесс выполнения.
     *
     * @return Ссылка на логическое значение, указывающее текущее состояние выполнения процессора.
     */
    const bool& IsRunning() const;

    /**
     * @brief Устанавливает значение регистра аккумулятор.
     *
     * Метод изменяет текущее значение аккумулятора на заданное. Если определён наблюдатель,
     * уведомляет его об изменении значения аккумулятора.
     *
     * @param value Новое значение, которое будет установлено в аккумуляторе.
     */
    template <typename T>
    void SetAccumulator(const T &value) {
        registers_.accumulator = value;

        if (observer_) {
            observer_->OnRegisterAccChanged(registers_.accumulator);
        }
    }

    /**
     * @brief Устанавливает значение вспомогательного регистра.
     *
     * Метод изменяет значение вспомогательного регистра на указанное.
     * Если зарегистрирован наблюдатель, он уведомляется об изменении значения регистра.
     *
     * @param value Новое значение, которое необходимо установить во вспомогательный регистр.
     */
    template <typename T>
    void SetAuxiliary(const T &value) {
        registers_.auxiliary = value;

        if (observer_) {
            observer_->OnRegisterAuxChanged(registers_.auxiliary);
        }
    }

private:
    MemoryManager& memory_; ///< Менеджер памяти
    ProcessorObserver* observer_; ///< Текущий наблюдатель состояния
    ProcessorIo* io_; ///< Обработчик ввода-вывода
    Registers registers_;
    bool is_running_; ///< Указывает, запущен ли процессор в текущий момент
    std::atomic<bool> is_waiting_input_{false}; ///< Признак, что процессор ожидает завершения ввода извне

    std::array<std::function<void()>, std::numeric_limits<common::Byte>::max() + 1> instructions_handlers_;
    std::array<common::ArgModifier, 4> argument_modifiers_;

    /**
     * @brief Выполняет текущую инструкцию процессора.
     *
     * Метод читает текущую инструкцию на основании указателя инструкции (IP) из памяти,
     * определяет обработчик для выполнения инструкции и вызывает соответствующий функциональный объект.
     * В случае ошибки чтения инструкции, её неправильного формата или отсутствия обработчика
     * устанавливается состояние остановки процессора и может выбрасываться исключение.
     *
     * @throws std::runtime_error Если обработчик инструкции не определен для кодов операции.
     */
    void ExecuteInstruction();
    /**
     * @brief Переходит к выполнению следующей инструкции в процессоре.
     *
     * Увеличивает значение регистра указателя инструкции (IP) на единицу, устанавливая его
     * на адрес следующей инструкции для последующего выполнения.
     */
    void NextInstruction();
    /**
     * @brief Устанавливает состояние процессора.
     *
     * Метод изменяет флаг выполнения процессора и уведомляет наблюдателя о произошедшем изменении, если он задан.
     *
     * @param is_running новое состояние процессора: `true` для запуска, `false` для остановки.
     */
    void SetStatus(bool is_running);

    /**
     * @brief Определяет тип данных в зависимости от переданного шаблонного параметра.
     *
     * Метод сравнивает тип шаблонного параметра T с предопределенными типами, такими как
     * common::Byte, common::Word, common::SignedWord, common::Real, и возвращает соответствующее значение из перечисления common::Type.
     *
     * @return Значение перечисления common::Type, соответствующее типу данных.
     */
    template <class T>
    static common::Type TypeIo();

    void Nope();
    template <typename T>
    void Add();
    template <class T>
    void Sub();
    template <class T>
    void Mul();
    template <class T>
    void Div();
    template <class T>
    void Mod();
    template <typename T>
    void Load();
    void Store();
    template <class T>
    void Input();
    template <class T>
    void Output();
    void Jump();
    template <class T>
    void SkipLower();
    template <class T>
    void SkipGreater();
    template <class T>
    void SkipEqual();
    void JumpAndStore();

    friend class AssemblerTest_Add_Test;

};

#endif
