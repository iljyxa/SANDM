<html><head><style>body {
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
                font-size: 14px;
                line-height: 1.6;
                color: #24292e;
                padding: 16px;
            }
            h1, h2, h3, h4, h5, h6 {
                margin-top: 24px;
                margin-bottom: 16px;
                font-weight: 600;
                line-height: 1.25;
            }
            h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
            h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
            pre {
                background-color: #f6f8fa;
                border-radius: 6px;
                padding: 16px;
                overflow: auto;
            }
            code {
                font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
                background-color: rgba(27,31,35,0.05);
                border-radius: 3px;
                padding: 0.2em 0.4em;
                font-size: 85%;
            }
            blockquote {
                border-left: 4px solid #dfe2e5;
                color: #6a737d;
                padding: 0 1em;
                margin-left: 0;
            }
            table {
                border-collapse: collapse;
                width: 100%;
                margin-bottom: 16px;
            }
            th, td {
                border: 1px solid #dfe2e5;
                padding: 6px 13px;
            }
            th {
                background-color: #f6f8fa;
                font-weight: 600;
            }
            tr:nth-child(even) { background-color: #f6f8fa; }
            a { color: #0366d6; text-decoration: none; }
            a:hover { text-decoration: underline; }</style></head><body><h1 id="simple-assembler-non-stack-demo-machine">Simple Assembler Non-stack Demo Machine</h1>
<h1 id="-">Содержание</h1>
<h2 id="-"><a href="#архитектура-процессора">Архитектура процессора</a></h2>
<ul>
<li><a href="#память">Память</a></li>
<li><a href="#регистры">Регистры</a></li>
<li><a href="#байт-код">Байт-код</a></li>
</ul>
<h2 id="-"><a href="#язык-ассемблера">Язык ассемблера</a></h2>
<ul>
<li><a href="#общий-синтаксис">Общий синтаксис</a></li>
<li><a href="#метки">Метки</a></li>
<li><a href="#команды">Команды</a></li>
<li><a href="#комментарии">Комментарии</a></li>
<li><a href="#числа">Числа</a></li>
</ul>
<h2 id="-"><a href="#набор-команд">Набор команд</a></h2>
<ul>
<li><a href="#модификаторы-типов">Модификаторы типов</a></li>
<li><a href="#модификатор-косвенной-адресации">Модификатор косвенной адресации</a></li>
<li><a href="#команды-процессора">Команды</a><ul>
<li><a href="#арифметические-команды">Арифметические</a></li>
<li><a href="#работа-с-памятью">Работа с памятью</a></li>
<li><a href="#вводвывод">Ввод/вывод</a></li>
<li><a href="#команды-переходов">Команды переходов</a></li>
</ul>
</li>
</ul>
<hr>
<h1 id="-">Архитектура процессора</h1>
<h2 id="-">Память</h2>
<ul>
<li><strong>Размер</strong>: 64 КБ (адреса от <code>0x0000</code> до <code>0xFFFF</code>).  </li>
<li><strong>Организация</strong>:  <ul>
<li>Каждая инструкция занимает 5 байт (1 байт — код операции, 4 байта — аргумент).  </li>
<li>Память разделена на области для кода и данных.  </li>
</ul>
</li>
</ul>
<h2 id="-">Регистры</h2>
<ul>
<li><strong>ACC (Accumulator)</strong>:  <ul>
<li><strong>Размер</strong>: 4 байта.  </li>
<li><strong>Назначение</strong>: Хранит результат операций. Доступен для чтения/записи через команды.  </li>
</ul>
</li>
<li><strong>AUX (Auxiliary)</strong>:  <ul>
<li><strong>Размер</strong>: 4 байта.  </li>
<li><strong>Назначение</strong>: Временное хранение аргументов. Недоступен напрямую для пользователя.  </li>
</ul>
</li>
<li><strong>IP (Instruction Pointer)</strong>:  <ul>
<li><strong>Размер</strong>: 2 байта.  </li>
<li><strong>Назначение</strong>: Счётчик команд. Изменяется командами <code>JUMP</code>, <code>SKIP*</code>, <code>JnS</code>.  </li>
</ul>
</li>
</ul>
<hr>
<h2 id="-">Байт-код</h2>
<p>Каждая инструкция кодируется в 5 байт: [ Код операции (1 байт) | Аргумент (4 байта) ].
Записываются последовательно. Каждая строка содержит 1 инструкцию.</p>
<p><strong>Код операции</strong>:</p>
<ul>
<li>Биты 7-3: Код команды (например, <code>ADD</code> → <code>00001</code>).  </li>
<li>Биты 2-1: Модификатор типа (<code>C</code>/<code>W</code>/<code>SW</code>/<code>R</code>).  </li>
<li>Бит 0: Модификатор аргумента (<code>0</code> — значение, <code>1</code> — адрес).</li>
</ul>
<p><strong>Операнд</strong>:</p>
<ul>
<li>4 байта (32 бита, порядок байтов little-endian).</li>
</ul>
<p>Пример для <code>ADD W &amp; 42</code>:  </p>
<pre><code class="lang-plaintext">Код операции: <span class="hljs-number">00001011</span> (<span class="hljs-keyword">ADD</span><span class="bash"> + W + REF)  
</span>Операнд: <span class="hljs-number">0</span>x0000002A (<span class="hljs-number">42</span> в hex)
</code></pre>
<hr>
<h1 id="-">Язык ассемблера</h1>
<h2 id="-">Общий синтаксис</h2>
<pre><code>&lt;Команда&gt; <span class="hljs-string">[Тип]</span> <span class="hljs-string">[&amp;|&amp;&amp;]</span> &lt;Операнд&gt;
</code></pre><ul>
<li><strong><code>[Тип]</code></strong> — модификатор типа определяет интерпретацию значения операнда:<ul>
<li><code>C</code> — константа.</li>
<li><code>W</code> — беззнаковое слово.</li>
<li><code>SW</code> — знаковое слово.</li>
<li><code>R</code> — вещественное число.</li>
</ul>
</li>
<li><strong><code>[&amp;|&amp;&amp;]</code></strong> — модификатор адреса.</li>
<li><strong><code>&lt;Операнд&gt;</code></strong> — число или адрес памяти.</li>
</ul>
<h2 id="-">Метки</h2>
<p>  Метка - это символическое имя, связанное с определенным адресом.
  Имя метки может содержать цифры, буквы латинского алфавита в верхнем и нижнем регистрах, а также символ &quot;_&quot;.
  Фактически, при обработке компилятором, вместо имени метки вставляется ее адрес в памяти.</p>
<p>  Имя метки не должно начинаться с цифры.</p>
<pre><code class="lang-asm"><span class="hljs-symbol">  label_name:</span>
</code></pre>
<p>  Для меток доступен синтаксис без указания команды, который позволяет использовать ее в виде переменной.</p>
<pre><code class="lang-asm">  label_name: <span class="hljs-string">[Тип]</span> Операнд
</code></pre>
<p>  Если в инструкции не указан операнд, то он по умолчанию равен 0, поэтому метка без указанного аргумента, эквивалентна переменной, инициализированной 0.
  В следующем примере метки label_name1, label_name2 эквивалентны.</p>
<pre><code class="lang-asm">  label_<span class="hljs-symbol">name1</span>: <span class="hljs-number">0</span>
  label_<span class="hljs-symbol">name2</span>:
  Add label_<span class="hljs-symbol">name1</span>
  <span class="hljs-keyword">Sub</span> label_<span class="hljs-symbol">name2</span>
</code></pre>
<h2 id="-">Команды</h2>
<p>  Команды являются регистронезависимыми.</p>
<pre><code class="lang-asm">  <span class="hljs-string">[Метка:]</span> КОМАНДА <span class="hljs-string">[Тип]</span> <span class="hljs-string">[Модификатор]</span> <span class="hljs-string">[Операнд]</span>
</code></pre>
<h2 id="-">Комментарии</h2>
<p>  Комментарием считается строка, начинающаяся с двух слэшей и до конца строки. Такие строки будут проигнорированы ассемблером.</p>
<pre><code class="lang-asm">  <span class="hljs-comment">// Это комментарий</span>
</code></pre>
<h2 id="-">Числа</h2>
<p>Поддерживаются десятичные (включая знаковые), с плавающей запятой, шестнадцатеричные (<code>0x</code>), бинарные (<code>0b</code>).</p>
<pre><code>```asm
Sub  <span class="hljs-number">-3</span>          <span class="hljs-comment">// Целое число</span>
Add R <span class="hljs-number">3.14</span>       <span class="hljs-comment">// Число с плавающей запятой</span>
Jump <span class="hljs-number">0</span>b01101111  <span class="hljs-comment">// Двоичное число</span>
JnS  <span class="hljs-number">0xFFFF</span>      <span class="hljs-comment">// Шестнадцатеричное число</span>
```
</code></pre><hr>
<h1 id="-">Набор команд</h1>
<h2 id="-">Модификаторы типов</h2>
<h3 id="-"><strong>Общие сведения</strong></h3>
<p>Модификаторы типов определяют, как процессор интерпретирует данные в регистрах или памяти <strong>во время выполнения операции</strong>. Они не преобразуют типы и не влияют на размер занимаемой памяти (все типы используют 4 байта).</p>
<h3 id="-"><strong>Список модификаторов</strong></h3>
<table>
<thead>
<tr>
<th>Модификатор</th>
<th>Полное название</th>
<th>Аналог</th>
<th>Размер</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>C</code></td>
<td>Char</td>
<td><code>uint8_t</code></td>
<td>1 байт</td>
<td>Беззнаковый байт (старшие 3 байта игнорируются).</td>
</tr>
<tr>
<td><code>W</code></td>
<td>Word</td>
<td><code>uint32_t</code></td>
<td>4 байта</td>
<td>Беззнаковое целое число.</td>
</tr>
<tr>
<td><code>SW</code></td>
<td>Signed Word</td>
<td><code>int32_t</code></td>
<td>4 байта</td>
<td>Знаковое целое число (дополнительный код).</td>
</tr>
<tr>
<td><code>R</code></td>
<td>Real</td>
<td><code>float</code></td>
<td>4 байта</td>
<td>Число с плавающей запятой (IEEE 754).</td>
</tr>
</tbody>
</table>
<h4 id="-"><strong>Общий принцип работы</strong></h4>
<ol>
<li><p><strong>Порядок выполнения</strong>:</p>
<ul>
<li>Значения загружаются по адресу (<strong>всегда как <code>W</code></strong>) из памяти (если требуется).</li>
<li>Байты значения загружаются в регистр AUX.</li>
<li>Процессор интерпретирует содержимое регистров (<code>ACC</code>, <code>AUX</code>) согласно модификатору типа.</li>
<li>Выполняется операция.</li>
</ul>
</li>
<li><p><strong>Пример для <code>Add R 0x3F800000</code></strong>:</p>
<pre><code class="lang-asm"><span class="hljs-number">1.</span> Memory[<span class="hljs-number">0xFF</span>] → AUX (как <span class="hljs-number">4</span> байта)
<span class="hljs-number">2.</span> ACC (<span class="hljs-number">4</span> байта) → интерпретация как `<span class="hljs-type">float</span>`
<span class="hljs-number">3.</span> AUX (<span class="hljs-number">4</span> байта) → интерпретация как `<span class="hljs-type">float</span>`
<span class="hljs-number">4.</span> Результат (ACC + AUX) → записывается в ACC (как `<span class="hljs-type">float</span>`)
</code></pre>
</li>
</ol>
<hr>
<h4 id="-"><strong>Важные замечания</strong></h4>
<ol>
<li><p><strong>Нет преобразования типов</strong>:</p>
<ul>
<li>Если в <code>ACC</code> было целое число (<code>SW</code>), а операция выполняется с <code>R</code>, результат будет некорректен (битовая интерпретация отличается).</li>
</ul>
</li>
<li><p><strong>Размер данных</strong>:</p>
<ul>
<li>Все типы используют 4 байта в памяти/регистрах, но:<ul>
<li>Для <code>C</code> учитывается только младший байт (остальные — нули).</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h2 id="-">Модификатор адресации</h2>
<p>Для многих команд доступны модификаторы <code>&amp;</code> и <code>&amp;</code>.</p>
<p>При использовании модификатора <code>&amp;</code>, операнд считается адресом в памяти, в котором расположено значение.
При использовании модификатора <code>&amp;</code>, операнд считается адресом в памяти, который ссылается на другой адрес, в котором расположено значение.
Если модификатор не указан, то операнд интерпретируется как значение.</p>
<p>Подробное описание того, как данный модификатор влияет на конкретную команду, указано в описании команд.</p>
<pre><code class="lang-asm"><span class="hljs-comment">// Пример поведения модификатора для арифметических команд</span>
<span class="hljs-comment">// Add X &lt;=&gt; Add Memory[X]</span>
<span class="hljs-comment">// Add &amp; X &lt;=&gt; Add Memory[Memory[X]]</span>
<span class="hljs-comment">// Где X - адрес</span>

Zero: 0  <span class="hljs-comment">// Адрес 0 </span>
<span class="hljs-keyword">Two</span>: 2   <span class="hljs-comment">// Адрес 1</span>
Three: 3 <span class="hljs-comment">// Адрес 2</span>
Load Zero <span class="hljs-comment">// ACC = 0</span>
Add <span class="hljs-keyword">Two</span> <span class="hljs-comment">// ACC = ACC + Two = 0 + 1 = 1</span>
        <span class="hljs-comment">// Метка Two указывает на адрес 1. Так как модификатор не указан, операнд считается значением.</span>
        <span class="hljs-comment">// Команда Add прибавляет к ACC значение 1.</span>
Add &amp; <span class="hljs-keyword">Two</span> <span class="hljs-comment">// ACC = ACC + Memory[Two] = 1 + Memory[1] = 1 + 2 = 3</span>
          <span class="hljs-comment">// Для команды указан модификатор аргумента, поэтому считается, что Two является адресом значения.</span>
Add &amp;&amp; <span class="hljs-keyword">Two</span> <span class="hljs-comment">// ACC = ACC + Memory[Memory[Two]] = 3 + Memory[Memory[1]] = 3 + Memory[2] = 3 + 3 = 6</span>
          <span class="hljs-comment">// Для команды указан двойной модификатор, поэтому считается, что Two является адресом другого адреса, который указывает на значение.</span>
          <span class="hljs-comment">// Значением адреса Two(1) является 2. По адресу 2 (Three) записано значение 3, которое будет использовано.</span>
</code></pre>
<h2 id="-"><strong>Команды</strong></h2>
<h3 id="-">Арифметические команды</h3>
<table>
<thead>
<tr>
<th>Команда</th>
<th>Формат</th>
<th>Описание</th>
<th>Эффект от <code>&amp;</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Add</code></td>
<td>`Add [C\</td>
<td>W\</td>
<td>SW\</td>
<td>R] [&amp;\</td>
<td>&amp;&amp;] X`</td>
<td>Сложение: <code>ACC += X</code> (или <code>Memory[X]</code>, или <code>Memory[Memory[X]]</code>).</td>
<td>Без &amp;: используется значение операнда при вычислении<br/>С &amp;: читается значение по адресу операнда<br/>С &amp;&amp;: читается адрес по адресу операнда, по которому читается значение.</td>
</tr>
<tr>
<td><code>Sub</code></td>
<td>`Sub [C\</td>
<td>W\</td>
<td>SW\</td>
<td>R] [&amp;\</td>
<td>&amp;&amp;] X`</td>
<td>Вычитание: <code>ACC -= X</code> (или <code>Memory[X]</code>, или <code>Memory[Memory[X]]</code>).</td>
<td>Аналогично <code>Add</code>.</td>
</tr>
<tr>
<td><code>Mul</code></td>
<td>`Mul [C\</td>
<td>W\</td>
<td>SW\</td>
<td>R] [&amp;\</td>
<td>&amp;&amp;] X`</td>
<td>Умножение: <code>ACC *= X</code> (или <code>Memory[X]</code>, или <code>Memory[Memory[X]]</code>).</td>
<td>Аналогично <code>Add</code>.</td>
</tr>
<tr>
<td><code>Div</code></td>
<td>`Div [C\</td>
<td>W\</td>
<td>SW\</td>
<td>R] [&amp;\</td>
<td>&amp;&amp;] X`</td>
<td>Деление: <code>ACC /= X</code> (или <code>Memory[X]</code>, или <code>Memory[Memory[X]]</code>).</td>
<td>Аналогично <code>Add</code>.</td>
</tr>
<tr>
<td><code>Mod</code></td>
<td>`Mod [C\</td>
<td>W\</td>
<td>SW] [&amp;\</td>
<td>&amp;&amp;] X`</td>
<td>Остаток от деления: <code>ACC %= X</code> (или <code>Memory[X]</code>, или <code>Memory[Memory[X]]</code>).</td>
<td>Аналогично <code>Add</code>.</td>
</tr>
</tbody>
</table>
<h3 id="-">Работа с памятью</h3>
<table>
<thead>
<tr>
<th>Команда</th>
<th>Формат</th>
<th>Описание</th>
<th>Эффект от <code>&amp;</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Load</code></td>
<td>`Load [W] [&amp;\</td>
<td>&amp;&amp;] X`</td>
<td>Загружает значение из памяти в регистр ACC. <code>ACC = X</code> (или <code>Memory[X]</code>, или <code>Memory[Memory[X]]</code>).</td>
<td>Без &amp;: загружает в регистр значение X<br/>С &amp;: читается значение по адресу X и загружается в регистр<br/>С &amp;&amp;: читается адрес по адресу X, по которому читается Memory[X], которое загружается в регистр.</td>
</tr>
<tr>
<td><code>Store</code></td>
<td><code>Store [W] [&amp;] X</code></td>
<td>Сохраняет значение из регистра ACC в память. <code>Memory[X] = ACC</code> (или <code>Memory[Memory[X]]</code>)</td>
<td>Без &amp;: записывает значение по адресу X<br/>С &amp;: записывает значение по адресу Memory[X]</td>
</tr>
</tbody>
</table>
<h3 id="-">Ввод/вывод</h3>
<table>
<thead>
<tr>
<th>Команда</th>
<th>Формат</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Input</code></td>
<td><code>Input [C|W|SW|R]</code></td>
<td>Ввод значения в регистр ACC с интерпретацией согласно указанному типу.</td>
</tr>
<tr>
<td><code>Output</code></td>
<td><code>Output [C|W|SW|R]</code></td>
<td>Вывод значения из регистра ACC с интерпретацией согласно указанному типу.</td>
</tr>
</tbody>
</table>
<h3 id="-">Команды переходов</h3>
<table>
<thead>
<tr>
<th>Команда</th>
<th>Формат</th>
<th>Описание</th>
<th>Эффект от <code>&amp;</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Jump</code></td>
<td><code>Jump [&amp;|&amp;&amp;] X</code></td>
<td>Безусловный переход по адресу <code>X</code> (или <code>Memory[X]</code>, или <code>Memory[Memory[X]]</code>).</td>
<td>Без &amp;: <code>X</code> является адресом перехода<br/>С &amp;: Значение по адресу <code>X</code> является адресом перехода<br/>С &amp;&amp;: Значение по адресу <code>X</code> является адресом, в котором записан адрес перехода.</td>
</tr>
<tr>
<td><code>JnS</code></td>
<td>`JnS [&amp;\</td>
<td>&amp;&amp;] X`</td>
<td>1. Сохраняет адрес следующей инструкции в <code>X</code> (или <code>Memory[X]</code>, или <code>Memory[Memory[X]]</code>)<br/>2. Выполняет переход на <code>X + 1</code> (или <code>Memory[X] + 1</code>, или <code>Memory[Memory[X]] + 1</code>).</td>
<td>Аналогично <code>Jump</code>.</td>
</tr>
<tr>
<td><code>SkipLo</code></td>
<td>`SkipLo [C\</td>
<td>W\</td>
<td>SW\</td>
<td>R] [&amp;\</td>
<td>&amp;&amp;] X`</td>
<td>Пропуск следующей инструкции, если <code>X</code> (или <code>Memory[X]</code>, или <code>Memory[Memory[X]]</code>) &lt; ACC.</td>
<td>Без &amp;: <code>X</code> является значением сравнения<br/>С &amp;: <code>X</code> является адресом, по которому записано значение сравнения<br/>С &amp;&amp;: Значение по адресу <code>X</code> является адресом, в котором записан адрес значения сравнения.</td>
</tr>
<tr>
<td><code>SkipGt</code></td>
<td>`SkipGt [C\</td>
<td>W\</td>
<td>SW\</td>
<td>R] [&amp;\</td>
<td>&amp;&amp;] X`</td>
<td>Пропуск следующей инструкции, если <code>X</code> (или <code>Memory[X]</code>, или <code>Memory[Memory[X]]</code>) &gt; ACC.</td>
<td>Аналогично <code>SkipLo</code>.</td>
</tr>
<tr>
<td><code>SkipEq</code></td>
<td>`SkipEq [C\</td>
<td>W\</td>
<td>SW\</td>
<td>R] [&amp;\</td>
<td>&amp;&amp;] X`</td>
<td>Пропуск следующей инструкции, если <code>X</code> (или <code>Memory[X]</code>, или <code>Memory[Memory[X]]</code>) == ACC.</td>
<td>Аналогично <code>SkipLo</code>.</td>
</tr>
</tbody>
</table>
</body></html>